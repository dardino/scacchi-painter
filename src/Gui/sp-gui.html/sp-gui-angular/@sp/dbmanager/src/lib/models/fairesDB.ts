/* eslint-disable @typescript-eslint/no-unused-vars */

export const FairyPiecesDB = {
  "15": "1,5-leaper",
  "16": "1,6-leaper",
  "24": "2,4-leaper",
  "25": "2,5-leaper",
  "35": "3,5-leaper",
  "36": "3,6-leaper",
  "37": "3,7-leaper",
  ah: "MAoHopper",
  al: "alfil",
  am: "amazon",
  an: "antelope",
  ao: "maorider",
  ar: "archbishop",
  b: "bishop",
  b1: "bouncer",
  b2: "rook bouncer",
  b3: "bishop bouncer",
  be: "bishop eagle",
  bh: "bishop hopper",
  bi: "bison 1,3+2,3 leaper",
  bk: "bouncy knight",
  bl: "bishop-lion",
  bm: "bishop moose",
  bn:
    "bouncy nightrider (continues ride by bouncing in any direction from board edge)",
  bo: "bob",
  bp: "berolina pawn",
  br: "bishop/rook hunter		absolute B/R hunter",
  bs: "berolina superpawn",
  bt: "boyscout",
  bu: "root-25-leaper (bucephale)",
  bw: "bishop sparrow",
  c: "cardinal",
  ca: "camel",
  cg: "contra grasshopper",
  ch: "camelrider hopper",
  cp: "chinese pawn",
  cr: "camelrider",
  ct: "CAT (cavalier trojan)",
  cy: "charybdis",
  da: "dabbabba",
  db: "doublebishopper",
  dg: "doublegrasshopper",
  dk: "doublerookhopper",
  do: "dolphingrasshopper + kangaroo",
  dr: "dragon",
  ds: "(\"Diagonalspiralspringer\")",
  du: "dummy",
  ea: "eagle",
  eh: "edgehog",
  ek: "erlking",
  em: "empress",
  eq: "equihopper",
  et: "elephant (0,1+1,1+1,2 rider)",
  f: "friend",
  fa: "faro (Argentinien Rook)",
  fe: "fers",
  fr: "fersrider (like bishop, but different rebirth square)",
  g: "grasshopper",
  g2: "grasshopper-2",
  g3: "grasshopper-3",
  ge: "greater treehopper",
  gf: "greater leafhopper",
  gh: "gnurider hopper",
  gi: "giraffe",
  gl: "gral   alfil + rookhopper",
  gn: "gnu",
  gr: "gnurider",
  gt: "girlscout",
  ha: "hamster",
  k: "king",
  ka: "kangaroo",
  kh: "kinghopper",
  kl: "kangaroo lion",
  ko: "kao",
  kp: "knight hopper",
  l: "locust",
  lb: "bishop locust",
  le: "leo",
  lh: "leaf hopper",
  li: "lion",
  ln: "nightrider locust",
  lo: "loco Argentinian Bishop",
  lr: "rook locust",
  ls: "rose locust",
  m: "moose",
  ma: "mao",
  mg: "marguerite (g+sw+ea+m+ha)",
  mh: "marine ship",
  ml: "maorider lion",
  mm: "moarider lion",
  mo: "moa",
  mp: "marine pawn",
  ms: "marine knight",
  n: "nightrider",
  na: "nao (chinese nightrider)",
  nd: "nereide",
  ne: "nonstop equihopper",
  nh: "nightrider hopper",
  nl: "nightrider lion",
  o: "orphan",
  oa: "moarider",
  oh: "MOaHopper",
  ok: "okapi (knight + zebra)",
  or: "OrixEnglish equihopper on queen lines",
  p: "pawn",
  pa: "pao",
  po: "poseidon",
  pp:
    "reverse pawn moves opposite to normal p and promotes at opp end of board",
  pr: "princess",
  q: "queen",
  qe: "equistopper (stoppable)",
  qf: "non-stop equistopper (not stoppable)",
  qn: "quintessence = (3,1)-Zigzag Nightrider (e.g. a1-b3-d2-e4-g3...)",
  qq: "querquisite",
  r: "rook",
  ra: "rao (chinese rose)",
  rb: "reflecting bishop",
  re: "rook eagle",
  rf: "root-50-leaper",
  rh: "rook hopper",
  rk: "radial leaper (aka radial knight)",
  rl: "rook-lion",
  rm: "rook moose",
  rn: "rose-lion",
  rp: "rose-hopper",
  ro: "rose",
  rr: "rook/bishop hunter (absolute R/B hunter)",
  rt: "rabbit",
  rw: "rook sparrow",
  s: "knight",
  s1: "(1,1)-Zigzag Nightrider (e.g. b1-a3-c2-b4-d3...)",
  s2: "(2,0)-Zigzag Nightrider (e.g. a1-b3-c1-d3-e1...)",
  s3: "(3,3)-Zigzag Nightrider (e.g. a1-b3-d4-e6-g7...)",
  s4: "(4,0)-Zigzag Nightrider (e.g. a1-c2-e1-g2...)",
  sa: "saltador (Argentinian Knight)",
  se: "senora (Argentinian Queen)",
  sh: "ship",
  si: "sirene",
  sk: "skylla",
  so: "scorpion",
  sp: "superpawn",
  sq: "squirrel",
  ss: "spiralspringer",
  st: "sting (king + royal grasshopper)",
  sw: "sparrow",
  th: "tree hopper",
  tr: "triton",
  uu: "ubiubi",
  va: "vao",
  wa: "waran",
  we: "wazir",
  wr: "wazirriderlike rook, but different rebirth square",
  z: "zebra",
  ze: "Zebu1,3+1,4 knight",
  zh: "zebrarider hopper",
  zr: "zebrarider",
  "X/Y": "X/Y hunter",
} as const;

export type FairyPiecesCodes = keyof typeof FairyPiecesDB;

type FE<T extends FairyPiecesCodes> = typeof FairyPiecesDB[T];
interface FairyItem<T extends FairyPiecesCodes> { code: T; descr: FE<T> }
type FairiesArray<X extends FairyPiecesCodes> = (X extends infer T ? FairyItem<X> : never)[];

export const FairyPieces = (Object.keys(FairyPiecesDB) as FairyPiecesCodes[]).map(
  k => ({
    code: k,
    descr: FairyPiecesDB[k],
  })
) as Readonly<FairiesArray<FairyPiecesCodes>>;

export const FairyAttributesDB = {
  Circe                      : { args: 1, Get: (options?: CirceOptions[]) => `Circe${options ? ` ${options.join(" ")}` : ""}` },
  AntiCirce                  : { args: 1, Get: (options?: CirceOptions[]) => `AntiCirce${options ? ` ${options.join(" ")}` : ""}` },
  Marscirce                  : { args: 1, Get: (options?: CirceOptions[]) => `Marscirce${options ? ` ${options.join(" ")}` : ""}` },
  AntiMarsCirce              : { args: 1, Get: (options?: CirceOptions[]) => `AntiMarsCirce${options ? ` ${options.join(" ")}` : ""}` },
  Madrasi                    : { args: 1, Get: (rexInclusive?: true) => `Madrasi${rexInclusive ? " RexInclusive" : ""}` },
  Volage                     : { args: 0, Get: () => "Volage" },
  Hypervolage                : { args: 0, Get: () => "Hypervolage" },
  BichromChess               : { args: 0, Get: () => "BichromChess" },
  MonochromChess             : { args: 0, Get: () => "MonochromChess" },
  GridChess                  : { args: 1, Get: (options: string) => `GridChess ${options}`.trim() },
  KoeKo                      : { args: 0, Get: () => "KoeKo" },
  BlackEdgemover             : { args: 0, Get: () => "BlackEdgemover" },
  WhiteEdgemover             : { args: 0, Get: () => "WhiteEdgemover" },
  Leofamily                  : { args: 0, Get: () => "Leofamily" },
  ChineseChess               : { args: 0, Get: () => "ChineseChess" },
  Patrouille                 : { args: 0, Get: () => "Patrouille" },
  NoCapture                  : { args: 0, Get: () => "NoCapture" },
  ImmunChess                 : { args: 0, Get: () => "ImmunChess" },
  ContactGridChess           : { args: 0, Get: () => "ContactGridChess" },
  Imitator                   : { args: 1, Get: (squares: string[]) => `Imitator ${squares.join(" ")}` },
  CavalierMajeur             : { args: 0, Get: () => "CavalierMajeur" },
  HaanerChess                : { args: 0, Get: () => "HaanerChess" },
  Sentinelles                : { args: 3, Get: (pion?: "PionAdvers" | "PionNeutre" | "ParaSentinelles" | "Berolina", maximum?: "MaximumWhite" | "MaximumBlack" | "MaximumTotal", maximumNumber?: number) =>    `Sentinelles${pion ? ` ${pion}` : ""}${maximum ? ` ${maximum}` : ""}${typeof maximumNumber === "number" ? ` ${maximumNumber}` : ""}` },
  Maximummer                 : { args: 1, Get: (ultra?: true) => `Maximummer${ultra ? " Ultra" : ""}` },
  UltraSchachZwang           : { args: 0, Get: () => "UltraSchachZwang" },
  BlackMaximummer            : { args: 1, Get: (ultra?: true) => `BlackMaximummer${ultra ? " Ultra" : ""}` },
  WhiteMaximummer            : { args: 1, Get: (ultra?: true) => `WhiteMaximummer${ultra ? " Ultra" : ""}` },
  WhiteUltraSchachZwang      : { args: 0, Get: () => "WhiteUltraSchachZwang" },
  BlackUltraSchachZwang      : { args: 0, Get: () => "BlackUltraSchachZwang" },
  BlackMinimummer            : { args: 1, Get: (ultra?: true) => `BlackMinimummer${ultra ? " Ultra" : ""}` },
  WhiteMinimummer            : { args: 1, Get: (ultra?: true) => `WhiteMinimummer${ultra ? " Ultra" : ""}` },
  MagicSquares               : { args: 2, Get: (squares: string[], type: "Type1" | "Type2" = "Type1") => `MagicSquares ${squares.join(" ")} ${type}` },
  Tibet                      : { args: 0, Get: () => "Tibet" },
  DoubleTibet                : { args: 0, Get: () => "DoubleTibet" },
  Hole                       : { args: 1, Get: (squares: string[]) => `Hole ${squares.join(" ")}` },
  BlackMustCapture           : { args: 1, Get: (ultra?: true) => `BlackMustCapture${ultra ? " Ultra" : ""}` },
  WhiteMustCapture           : { args: 1, Get: (ultra?: true) => `WhiteMustCapture${ultra ? " Ultra" : ""}` },
  TransmutedKings            : { args: 0, Get: () => "TransmutedKings" },
  BlackFollowMyLeader        : { args: 0, Get: () => "BlackFollowMyLeader" },
  WhiteFollowMyLeader        : { args: 0, Get: () => "WhiteFollowMyLeader" },
  DuellistChess              : { args: 0, Get: () => "DuellistChess" },
  NoIProm                    : { args: 0, Get: () => "NoIProm" },
  VogtlaenderChess           : { args: 0, Get: () => "VogtlaenderChess" },
  EinsteinChess              : { args: 0, Get: () => "EinsteinChess" },
  Bicolores                  : { args: 0, Get: () => "Bicolores" },
  NewKoeko                   : { args: 0, Get: () => "NewKoeko" },
  ReversalEinsteinChess      : { args: 0, Get: () => "ReversalEinsteinChess" },
  RelegationChess            : { args: 0, Get: () => "RelegationChess" },
  NorskSjakk                 : { args: 0, Get: () => "NorskSjakk" },
  TraitorChess               : { args: 0, Get: () => "TraitorChess" },
  AndernachChess             : { args: 0, Get: () => "AndernachChess" },
  BlackForcedSquare          : { args: 1, Get: (squares: string[]) => `BlackForcedSquare ${squares.join(" ")}` },
  WhiteForcedSquare          : { args: 1, Get: (squares: string[]) => `WhiteForcedSquare ${squares.join(" ")}` },
  BlackConsequentForcedSquare: { args: 1, Get: (squares: string[]) => `BlackConsequentForcedSquare ${squares.join(" ")}` },
  WhiteConsequentForcedSquare: { args: 1, Get: (squares: string[]) => `WhiteConsequentForcedSquare ${squares.join(" ")}` },
  ReflectiveKings            : { args: 0, Get: () => "ReflectiveKings" },
  ChameleonChess             : { args: 1, Get: (sequence: string[]) => `ChameleonChess ${sequence.join(" ")}` },
  FunctionaryChess           : { args: 0, Get: () => "FunctionaryChess" },
  GlasgowChess               : { args: 0, Get: () => "GlasgowChess" },
  AntiAndernachChess         : { args: 0, Get: () => "AntiAndernachChess" },
  Isardam                    : { args: 2, Get: (typeB?: true, rexInclusive?: true) => `Isardam${typeB ? " TypeB" : ""}${rexInclusive ? " RexInclusive" : ""}` },
  ChecklessChess             : { args: 0, Get: () => "ChecklessChess" },
  PromOnly                   : { args: 1, Get: (piecetypes: FairyPiecesCodes[]) => `PromOnly ${piecetypes.join(" ")}` },
  ExclusiveChess             : { args: 0, Get: () => "ExclusiveChess" },
  PhantomChess               : { args: 0, Get: () => "PhantomChess" },
  WhiteTransmutedKing        : { args: 0, Get: () => "WhiteTransmutedKing" },
  BlackTransmutedKing        : { args: 0, Get: () => "BlackTransmutedKing" },
  WhiteReflectiveKing        : { args: 0, Get: () => "WhiteReflectiveKing" },
  BlackReflectiveKing        : { args: 0, Get: () => "BlackReflectiveKing" },
  AntiEinsteinChess          : { args: 0, Get: () => "AntiEinsteinChess" },
  BlackRoyalSquare           : { args: 0, Get: () => "BlackRoyalSquare" },
  WhiteRoyalSquare           : { args: 0, Get: () => "WhiteRoyalSquare" },
  PlusChess                  : { args: 0, Get: () => "PlusChess" },
  BrunnerChess               : { args: 0, Get: () => "BrunnerChess" },
  CentralChess               : { args: 0, Get: () => "CentralChess" },
  ExtinctionChess            : { args: 0, Get: () => "ExtinctionChess" },
  RepublicanChess            : { args: 1, Get: (type: "Type1" | "Type2" = "Type2") => `RepublicanChess ${type}` },
  ActuatedRevolvingBoard     : { args: 0, Get: () => "ActuatedRevolvingBoard" },
  MessignyChess              : { args: 1, Get: (rexExclusive?: true) => `MessignyChess${rexExclusive ? " RexExclusive" : ""}` },
  Woozles                    : { args: 1, Get: (rexExclusive?: true) => `Woozles${rexExclusive ? " RexExclusive" : ""}` },
  BiWoozles                  : { args: 1, Get: (rexExclusive?: true) => `BiWoozles${rexExclusive ? " RexExclusive" : ""}` },
  Heffalumps                 : { args: 1, Get: (rexExclusive?: true) => `Heffalumps${rexExclusive ? " RexExclusive" : ""}` },
  BiHeffalumps               : { args: 1, Get: (rexExclusive?: true) => `BiHeffalumps${rexExclusive ? " RexExclusive" : ""}` },
  WhitePromSquares           : { args: 1, Get: (squares: string[]) => `WhitePromSquares ${squares.join(" ")}` },
  BlackPromSquares           : { args: 1, Get: (squares: string[]) => `BlackPromSquares ${squares.join(" ")}` },
  NoWhitePromotion           : { args: 0, Get: () => "NoWhitePromotion" },
  NoBlackPromotion           : { args: 0, Get: () => "NoBlackPromotion" },
  EiffelChess                : { args: 0, Get: () => "EiffelChess" },
  ActuatedRevolvingCentre    : { args: 0, Get: () => "ActuatedRevolvingCentre" },
  ShieldedKings              : { args: 0, Get: () => "ShieldedKings" },
  NoWhiteCapture             : { args: 0, Get: () => "NoWhiteCapture" },
  NoBlackCapture             : { args: 0, Get: () => "NoBlackCapture" },
  AlphabeticChess            : { args: 0, Get: () => "AlphabeticChess" },
  LineChameleonChess         : { args: 0, Get: () => "LineChameleonChess" },
  AMU                        : { args: 0, Get: () => "AMU" },
  SingleBox                  : { args: 1, Get: (type: "Type1" | "Type2" | "Type3" = "Type2") =>    `SingleBox ${type}` },
  MAFF                       : { args: 0, Get: () => "MAFF" },
  OWU                        : { args: 0, Get: () => "OWU" },
  WhiteOscillatingKings      : { args: 1, Get: (type?: "TypeB" | "TypeC") => `WhiteOscillatingKings ${type}`.trim() },
  BlackOscillatingKings      : { args: 1, Get: (type?: "TypeB" | "TypeC") => `BlackOscillatingKings ${type}`.trim() },
  AntiKings                  : { args: 0, Get: () => "AntiKings" },
  WhiteSuperTransmutingKing  : { args: 0, Get: () => "WhiteSuperTransmutingKing" },
  BlackSuperTransmutingKing  : { args: 0, Get: () => "BlackSuperTransmutingKing" },
  UltraPatrol                : { args: 0, Get: () => "UltraPatrol" },
  SwappingKings              : { args: 0, Get: () => "SwappingKings" },
  RoyalDynasty               : { args: 0, Get: () => "RoyalDynasty" },
  SAT                        : { args: 0, Get: () => "SAT" },
  StrictSAT                  : { args: 0, Get: () => "StrictSAT" },
  TakeMakeChess              : { args: 0, Get: () => "Take&MakeChess" },
  MakeTakeChess              : { args: 0, Get: () => "Make&TakeChess" },
  BlackSynchronMover         : { args: 0, Get: () => "BlackSynchronMover" },
  WhiteSynchronMover         : { args: 0, Get: () => "WhiteSynchronMover" },
  BlackAntiSynchronMover     : { args: 0, Get: () => "BlackAntiSynchronMover" },
  WhiteAntiSynchronMover     : { args: 0, Get: () => "WhiteAntiSynchronMover" },
  Masand                     : { args: 0, Get: () => "Masand" },
  MasandGeneralised          : { args: 0, Get: () => "MasandGeneralised" },
  BGL                        : { args: 0, Get: () => "BGL" },
  AnnanChess                 : { args: 0, Get: () => "AnnanChess" },
  NannaChess                 : { args: 0, Get: () => "NannaChess" },
  NormalPawn                 : { args: 0, Get: () => "NormalPawn" },
  BlackChecks                : { args: 0, Get: () => "BlackChecks" },
  GenevaChess                : { args: 0, Get: () => "GenevaChess" },
  VaultingKings              : { args: 2, Get: (pieceTypes?: string[], transmuting?: true) => `VaultingKings ${pieceTypes?.join(" ")}${transmuting ? " Transmuting" : ""}`.trim() },
  WhiteVaultingKing          : { args: 0, Get: () => "WhiteVaultingKing" },
  BlackVaultingKing          : { args: 0, Get: () => "BlackVaultingKing" },
  ProteanChess               : { args: 1, Get: (rexExclusive?: true) => `ProteanChess${rexExclusive ? " RexExclusive" : ""}` },
  Lortap                     : { args: 0, Get: () => "Lortap" },
  Antikoeko                  : { args: 0, Get: () => "Antikoeko" },
  CastlingChess              : { args: 0, Get: () => "CastlingChess" },
  ChameleonPursuit           : { args: 0, Get: () => "ChameleonPursuit" },
  LosingChess                : { args: 0, Get: () => "LosingChess" },
  GhostChess                 : { args: 0, Get: () => "GhostChess" },
  Football                   : { args: 0, Get: () => "Football" },
  WhiteAlphabeticChess       : { args: 0, Get: () => "WhiteAlphabeticChess" },
  BlackAlphabeticChess       : { args: 0, Get: () => "BlackAlphabeticChess" },
  KobulKings                 : { args: 0, Get: () => "KobulKings" },
  SuperGuards                : { args: 0, Get: () => "SuperGuards" },
  Wormholes                  : { args: 0, Get: () => "Wormholes" },
  MarineChess                : { args: 0, Get: () => "MarineChess" },
  UltramarineChess           : { args: 0, Get: () => "UltramarineChess" },
  BackHome                   : { args: 0, Get: () => "BackHome" },
  FaceToFace                 : { args: 0, Get: () => "FaceToFace" },
  BackToBack                 : { args: 0, Get: () => "BackToBack" },
  CheekToCheek               : { args: 0, Get: () => "CheekToCheek" },
  Disparate                  : { args: 0, Get: () => "Disparate" },
  SnekChess                  : { args: 0, Get: () => "SnekChess" },
  SnekCircleChess            : { args: 0, Get: () => "SnekCircleChess" },
  ArgentinianChess           : { args: 0, Get: () => "ArgentinianChess" },
  LostPieces                 : { args: 0, Get: () => "LostPieces" },
  PartialParalysis           : { args: 0, Get: () => "PartialParalysis" },
  LeseMajeste                : { args: 0, Get: () => "LeseMajeste" },
  Rokagogo                   : { args: 0, Get: () => "Rokagogo" },
  Breton                     : { args: 0, Get: () => "Breton" },
  PointReflection            : { args: 0, Get: () => "PointReflection" },
  Bolero                     : { args: 0, Get: () => "Bolero" },
  BoleroInverse              : { args: 0, Get: () => "BoleroInverse" },
  Influencer                 : { args: 0, Get: () => "Influencer" },
  ChameleonCirce             : { args: 1, Get: (sequence: string[]) => `ChameleonCirce ${sequence.join(" ")}` },
} as const;

export type FairyAttributesDBNames = keyof typeof FairyAttributesDB;
export const FairyAttributesDBNames: FairyAttributesDBNames[] = Object.keys(
  FairyAttributesDB
) as FairyAttributesDBNames[];

export const CirceOptions = {
  RexInclusive: {
    description: "(default for AntiCirce and MarsCirce)",
    group: "Inclusion of the kings",
  },
  RexExclusive: {
    description: "(default otherwise)",
    group: "Inclusion of the kings",
  },
  LastMove: { description: "", group: "Relevant move/walk/side" },
  Clone: {
    description: "(also defines the walk of the reborn piece)",
    group: "Relevant move/walk/side",
  },
  Couscous: { description: "", group: "Relevant move/walk/side" },
  Mirror: {
    description: "(special meaning for Equipollents - see below)",
    group: "Relevant move/walk/side",
  },
  April: {
    description: "(followed by a list of piece walks)",
    group: "Restrition to piece walk",
  },
  Equipollents: {
    description: "",
    group: "Definition of the rebirth square(s)",
  },
  Parrain: {
    description: "(== Equipollents LastMove)",
    group: "Definition of the rebirth square(s)",
  },
  ContraParrain: {
    description: "(== Equipollents LastMove Mirror)",
    group: "Definition of the rebirth square(s)",
  },
  Rank: { description: "", group: "Definition of the rebirth square(s)" },
  File: { description: "", group: "Definition of the rebirth square(s)" },
  Symmetry: { description: "", group: "Definition of the rebirth square(s)" },
  Diagram: { description: "", group: "Definition of the rebirth square(s)" },
  PWC: { description: "", group: "Definition of the rebirth square(s)" },
  Antipodes: { description: "", group: "Definition of the rebirth square(s)" },
  Super: { description: "", group: "Definition of the rebirth square(s)" },
  "Take&Make": {
    description: "",
    group: "Definition of the rebirth square(s)",
  },
  Cage: { description: "", group: "Definition of the rebirth square(s)" },
  Diametral: { description: "", group: "Adaptation of the rebirth square" },
  VerticalMirror: {
    description: "",
    group: "Adaptation of the rebirth square",
  },
  Frischauf: { description: "", group: "Adaptation of the rebirth square" },
  "(Rank)": { description: "", group: "Adaptation of the rebirth square" },
  Chameleon: {
    description: "",
    group: "Adaptation of the reborn piece's walk",
  },
  Turncoat: { description: "", group: "Adaptation of the reborn piece's walk" },
  Einstein: { description: "", group: "Adaptation of the reborn piece's walk" },
  ReversalEinstein: {
    description: "",
    group: "Adaptation of the reborn piece's walk",
  },
  Relaxed: {
    description: "(default for Circe)",
    group: "Behaviour in case of occupied rebirth square",
  },
  Strict: {
    description: "(default otherwise)",
    group: "Behaviour in case of occupied rebirth square",
  },
  Assassin: {
    description: "",
    group: "Behaviour in case of occupied rebirth square",
  },
  Volcanic: {
    description: "",
    group: "Behaviour in case of occupied rebirth square",
  },
  Parachute: {
    description: "",
    group: "Behaviour in case of occupied rebirth square",
  },
  Calvet: { description: "(default)", group: "Self-block of the reborn piece" },
  Cheylan: { description: "", group: "Self-block of the reborn piece" },
} as const;

export type CirceOptions = keyof typeof CirceOptions;

/*

    The following "traditional" condition names can still be used;
  RexInclusive resp. RexExclusive can be added:

    traditional:		  Indication with option(s):

*/

export const TraditionalConditions = {
  MirrorCirce            : (rex: "Inclusive"| "Exclusive") => "Circe Mirror",
  PWC                    : (rex: "Inclusive"| "Exclusive") => "Circe PWC",
  CouscousCirce          : (rex: "Inclusive"| "Exclusive") => "Circe Couscous",
  ChameleonCirce         : (rex: "Inclusive"| "Exclusive") => "Circe Chameleon",
  EquipollentsCirce      : (rex: "Inclusive"| "Exclusive") => "Circe Equipollents",
  FileCirce              : (rex: "Inclusive"| "Exclusive") => "Circe File",
  DiagramCirce           : (rex: "Inclusive"| "Exclusive") => "Circe Diagram",
  ParrainCirce           : (rex: "Inclusive"| "Exclusive") => "Circe LastMove Equipollents",
  ContraParrain          : (rex: "Inclusive"| "Exclusive") => "Circe LastMove Equipollents Mirror",
  SymmetryCirce          : (rex: "Inclusive"| "Exclusive") => "Circe Symmetry",
  MirrorFileCirce        : (rex: "Inclusive"| "Exclusive") => "Circe File Mirror",
  AntipodeanCirce        : (rex: "Inclusive"| "Exclusive") => "Circe Antipodes",
  MirrorCirceClone       : (rex: "Inclusive"| "Exclusive") => "Circe Clone Mirror",
  SuperCirce             : (rex: "Inclusive"| "Exclusive") => "Circe Super",
  CirceClone             : (rex: "Inclusive"| "Exclusive") => "Circe Clone",
  FrischaufCirce         : (rex: "Inclusive"| "Exclusive") => "Circe Frischauf",
  DiametralCirce         : (rex: "Inclusive"| "Exclusive") => "Circe Diametral",
  MirrorCouscousCirce    : (rex: "Inclusive"| "Exclusive") => "Circe Couscous Mirror",
  CirceAssassin          : (rex: "Inclusive"| "Exclusive") => "Circe Assassin",
  CirceTurncoats         : (rex: "Inclusive"| "Exclusive") => "Circe Turncoat",
  CirceDoubleAgents      : (rex: "Inclusive"| "Exclusive") => "Circe Turncoat Mirror",
  CageCirce              : (rex: "Inclusive"| "Exclusive") => "Circe Cage",
  CirceTakeMake          : (rex: "Inclusive"| "Exclusive") => "Circe Take&Make", // (also known as Anti-Take&Make
  VerticalMirrorCirce    : (rex: "Inclusive"| "Exclusive") => "Circe VerticalMirror",
  AprilChess             : (rex: "Inclusive"| "Exclusive") => "Circe Super April",
  MirrorAntiCirce        : (rex: "Inclusive"| "Exclusive") => "AntiCirce Mirror",
  DiagramAntiCirce       : (rex: "Inclusive"| "Exclusive") => "AntiCirce Diagram",
  FileAntiCirce          : (rex: "Inclusive"| "Exclusive") => "AntiCirce File",
  SymmetryAntiCirce      : (rex: "Inclusive"| "Exclusive") => "AntiCirce Symmetry",
  MirrorFileAnticirce    : (rex: "Inclusive"| "Exclusive") => "AntiCirce File Mirror",
  AntipodeanAntiCirce    : (rex: "Inclusive"| "Exclusive") => "AntiCirce Antipodes",
  EquipollentsAntiCirce  : (rex: "Inclusive"| "Exclusive") => "AntiCirce Equipollents",
  AntiCloneCirce         : (rex: "Inclusive"| "Exclusive") => "AntiCirce Clone",
  AntiSuperCirce         : (rex: "Inclusive"| "Exclusive") => "AntiCirce Super",
  MarsMirrorCirce        : (rex: "Inclusive"| "Exclusive") => "MarsCirce Mirror",
  AntiMarsMirrorCirce    : (rex: "Inclusive"| "Exclusive") => "AntiMarsCirce Mirror",
  AntiMarsAntipodeanCirce: (rex: "Inclusive"| "Exclusive") => "AntiMarsCirce Antipodes",
  MirrorImmunChess       : (rex: "Inclusive"| "Exclusive") => "ImmunChess Mirror",
  FileImmunChess         : (rex: "Inclusive"| "Exclusive") => "ImmunChess File",
  DiagramImmunChess      : (rex: "Inclusive"| "Exclusive") => "ImmunChess Diagram",
  MirrorFileImmunChess   : (rex: "Inclusive"| "Exclusive") => "ImmunChess File Mirror",
  SymmetryImmunChess     : (rex: "Inclusive"| "Exclusive") => "ImmunChess Symmetry",
  AntipodeanImmunChess   : (rex: "Inclusive"| "Exclusive") => "ImmunChess Antipodes",
  EquipollentsImmunChess : (rex: "Inclusive"| "Exclusive") => "ImmunChess Equipollents",
} as const;

export const isTraditionalCondition=(v: unknown): v is TraditionalConditionsNames => TraditionalConditionsNames.indexOf(v as TraditionalConditionsNames) >= 0;

export type TraditionalConditionsNames = keyof typeof TraditionalConditions;
export const TraditionalConditionsNames: TraditionalConditionsNames[] = Object.keys(TraditionalConditions) as TraditionalConditionsNames[];

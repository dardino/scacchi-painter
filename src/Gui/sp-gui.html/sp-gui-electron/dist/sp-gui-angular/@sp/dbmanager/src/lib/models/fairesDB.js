"use strict";
// tslint:disable: object-literal-key-quotes
// tslint:disable: max-line-length
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraditionalConditionsNames = exports.isTraditionalCondition = exports.TraditionalConditions = exports.CirceOptions = exports.FairyAttributesDBNames = exports.FairyAttributesDB = exports.FairyPieces = exports.FairyPiecesDB = void 0;
exports.FairyPiecesDB = {
    "15": "1,5-leaper",
    "16": "1,6-leaper",
    "24": "2,4-leaper",
    "25": "2,5-leaper",
    "35": "3,5-leaper",
    "36": "3,6-leaper",
    "37": "3,7-leaper",
    ah: "MAoHopper",
    al: "alfil",
    am: "amazon",
    an: "antelope",
    ao: "maorider",
    ar: "archbishop",
    b: "bishop",
    b1: "bouncer",
    b2: "rook bouncer",
    b3: "bishop bouncer",
    be: "bishop eagle",
    bh: "bishop hopper",
    bi: "bison 1,3+2,3 leaper",
    bk: "bouncy knight",
    bl: "bishop-lion",
    bm: "bishop moose",
    bn: "bouncy nightrider (continues ride by bouncing in any direction from board edge)",
    bo: "bob",
    bp: "berolina pawn",
    br: "bishop/rook hunter		absolute B/R hunter",
    bs: "berolina superpawn",
    bt: "boyscout",
    bu: "root-25-leaper (bucephale)",
    bw: "bishop sparrow",
    c: "cardinal",
    ca: "camel",
    cg: "contra grasshopper",
    ch: "camelrider hopper",
    cp: "chinese pawn",
    cr: "camelrider",
    ct: "CAT (cavalier trojan)",
    cy: "charybdis",
    da: "dabbabba",
    db: "doublebishopper",
    dg: "doublegrasshopper",
    dk: "doublerookhopper",
    do: "dolphingrasshopper + kangaroo",
    dr: "dragon",
    ds: `("Diagonalspiralspringer")`,
    du: "dummy",
    ea: "eagle",
    eh: "edgehog",
    ek: "erlking",
    em: "empress",
    eq: "equihopper",
    et: "elephant (0,1+1,1+1,2 rider)",
    f: "friend",
    fa: "faro (Argentinien Rook)",
    fe: "fers",
    fr: "fersrider (like bishop, but different rebirth square)",
    g: "grasshopper",
    g2: "grasshopper-2",
    g3: "grasshopper-3",
    ge: "greater treehopper",
    gf: "greater leafhopper",
    gh: "gnurider hopper",
    gi: "giraffe",
    gl: "gral   alfil + rookhopper",
    gn: "gnu",
    gr: "gnurider",
    gt: "girlscout",
    ha: "hamster",
    k: "king",
    ka: "kangaroo",
    kh: "kinghopper",
    kl: "kangaroo lion",
    ko: "kao",
    kp: "knight hopper",
    l: "locust",
    lb: "bishop locust",
    le: "leo",
    lh: "leaf hopper",
    li: "lion",
    ln: "nightrider locust",
    lo: "loco Argentinian Bishop",
    lr: "rook locust",
    ls: "rose locust",
    m: "moose",
    ma: "mao",
    mg: "marguerite (g+sw+ea+m+ha)",
    mh: "marine ship",
    ml: "maorider lion",
    mm: "moarider lion",
    mo: "moa",
    mp: "marine pawn",
    ms: "marine knight",
    n: "nightrider",
    na: "nao (chinese nightrider)",
    nd: "nereide",
    ne: "nonstop equihopper",
    nh: "nightrider hopper",
    nl: "nightrider lion",
    o: "orphan",
    oa: "moarider",
    oh: "MOaHopper",
    ok: "okapi (knight + zebra)",
    or: "OrixEnglish equihopper on queen lines",
    p: "pawn",
    pa: "pao",
    po: "poseidon",
    pp: "reverse pawn moves opposite to normal p and promotes at opp end of board",
    pr: "princess",
    q: "queen",
    qe: "equistopper (stoppable)",
    qf: "non-stop equistopper (not stoppable)",
    qn: "quintessence = (3,1)-Zigzag Nightrider (e.g. a1-b3-d2-e4-g3...)",
    qq: "querquisite",
    r: "rook",
    ra: "rao (chinese rose)",
    rb: "reflecting bishop",
    re: "rook eagle",
    rf: "root-50-leaper",
    rh: "rook hopper",
    rk: "radial leaper (aka radial knight)",
    rl: "rook-lion",
    rm: "rook moose",
    rn: "rose-lion",
    rp: "rose-hopper",
    ro: "rose",
    rr: "rook/bishop hunter (absolute R/B hunter)",
    rt: "rabbit",
    rw: "rook sparrow",
    s: "knight",
    s1: "(1,1)-Zigzag Nightrider (e.g. b1-a3-c2-b4-d3...)",
    s2: "(2,0)-Zigzag Nightrider (e.g. a1-b3-c1-d3-e1...)",
    s3: "(3,3)-Zigzag Nightrider (e.g. a1-b3-d4-e6-g7...)",
    s4: "(4,0)-Zigzag Nightrider (e.g. a1-c2-e1-g2...)",
    sa: "saltador (Argentinian Knight)",
    se: "senora (Argentinian Queen)",
    sh: "ship",
    si: "sirene",
    sk: "skylla",
    so: "scorpion",
    sp: "superpawn",
    sq: "squirrel",
    ss: `spiralspringer`,
    st: "sting (king + royal grasshopper)",
    sw: "sparrow",
    th: "tree hopper",
    tr: "triton",
    uu: "ubiubi",
    va: "vao",
    wa: "waran",
    we: "wazir",
    wr: "wazirriderlike rook, but different rebirth square",
    z: "zebra",
    ze: "Zebu1,3+1,4 knight",
    zh: "zebrarider hopper",
    zr: "zebrarider",
    "X/Y": "X/Y hunter",
};
exports.FairyPieces = Object.keys(exports.FairyPiecesDB).map(k => ({
    code: k,
    descr: exports.FairyPiecesDB[k],
}));
exports.FairyAttributesDB = {
    Circe: { args: 1, Get: (options) => `Circe${options ? ` ${options.join(" ")}` : ""}` },
    AntiCirce: { args: 1, Get: (options) => `AntiCirce${options ? ` ${options.join(" ")}` : ""}` },
    Marscirce: { args: 1, Get: (options) => `Marscirce${options ? ` ${options.join(" ")}` : ""}` },
    AntiMarsCirce: { args: 1, Get: (options) => `AntiMarsCirce${options ? ` ${options.join(" ")}` : ""}` },
    Madrasi: { args: 1, Get: (rexInclusive) => `Madrasi${rexInclusive ? " RexInclusive" : ""}` },
    Volage: { args: 0, Get: () => `Volage` },
    Hypervolage: { args: 0, Get: () => `Hypervolage` },
    BichromChess: { args: 0, Get: () => `BichromChess` },
    MonochromChess: { args: 0, Get: () => `MonochromChess` },
    GridChess: { args: 1, Get: (options) => `GridChess ${options}`.trim() },
    KoeKo: { args: 0, Get: () => `KoeKo` },
    BlackEdgemover: { args: 0, Get: () => `BlackEdgemover` },
    WhiteEdgemover: { args: 0, Get: () => `WhiteEdgemover` },
    Leofamily: { args: 0, Get: () => `Leofamily` },
    ChineseChess: { args: 0, Get: () => `ChineseChess` },
    Patrouille: { args: 0, Get: () => `Patrouille` },
    NoCapture: { args: 0, Get: () => `NoCapture` },
    ImmunChess: { args: 0, Get: () => `ImmunChess` },
    ContactGridChess: { args: 0, Get: () => `ContactGridChess` },
    Imitator: { args: 1, Get: (squares) => `Imitator ${squares.join(" ")}` },
    CavalierMajeur: { args: 0, Get: () => `CavalierMajeur` },
    HaanerChess: { args: 0, Get: () => `HaanerChess` },
    Sentinelles: { args: 3, Get: (pion, maximum, maximumNumber) => `Sentinelles${pion ? ` ${pion}` : ""}${maximum ? ` ${maximum}` : ""}${typeof maximumNumber === "number" ? ` ${maximumNumber}` : ""}` },
    Maximummer: { args: 1, Get: (ultra) => `Maximummer${ultra ? " Ultra" : ""}` },
    UltraSchachZwang: { args: 0, Get: () => `UltraSchachZwang` },
    BlackMaximummer: { args: 1, Get: (ultra) => `BlackMaximummer${ultra ? " Ultra" : ""}` },
    WhiteMaximummer: { args: 1, Get: (ultra) => `WhiteMaximummer${ultra ? " Ultra" : ""}` },
    WhiteUltraSchachZwang: { args: 0, Get: () => `WhiteUltraSchachZwang` },
    BlackUltraSchachZwang: { args: 0, Get: () => `BlackUltraSchachZwang` },
    BlackMinimummer: { args: 1, Get: (ultra) => `BlackMinimummer${ultra ? " Ultra" : ""}` },
    WhiteMinimummer: { args: 1, Get: (ultra) => `WhiteMinimummer${ultra ? " Ultra" : ""}` },
    MagicSquares: { args: 2, Get: (squares, type = "Type1") => `MagicSquares ${squares.join(" ")} ${type}` },
    Tibet: { args: 0, Get: () => `Tibet` },
    DoubleTibet: { args: 0, Get: () => `DoubleTibet` },
    Hole: { args: 1, Get: (squares) => `Hole ${squares.join(" ")}` },
    BlackMustCapture: { args: 1, Get: (ultra) => `BlackMustCapture${ultra ? " Ultra" : ""}` },
    WhiteMustCapture: { args: 1, Get: (ultra) => `WhiteMustCapture${ultra ? " Ultra" : ""}` },
    TransmutedKings: { args: 0, Get: () => `TransmutedKings` },
    BlackFollowMyLeader: { args: 0, Get: () => `BlackFollowMyLeader` },
    WhiteFollowMyLeader: { args: 0, Get: () => `WhiteFollowMyLeader` },
    DuellistChess: { args: 0, Get: () => `DuellistChess` },
    NoIProm: { args: 0, Get: () => `NoIProm` },
    VogtlaenderChess: { args: 0, Get: () => `VogtlaenderChess` },
    EinsteinChess: { args: 0, Get: () => `EinsteinChess` },
    Bicolores: { args: 0, Get: () => `Bicolores` },
    NewKoeko: { args: 0, Get: () => `NewKoeko` },
    ReversalEinsteinChess: { args: 0, Get: () => `ReversalEinsteinChess` },
    RelegationChess: { args: 0, Get: () => `RelegationChess` },
    NorskSjakk: { args: 0, Get: () => `NorskSjakk` },
    TraitorChess: { args: 0, Get: () => `TraitorChess` },
    AndernachChess: { args: 0, Get: () => `AndernachChess` },
    BlackForcedSquare: { args: 1, Get: (squares) => `BlackForcedSquare ${squares.join(" ")}` },
    WhiteForcedSquare: { args: 1, Get: (squares) => `WhiteForcedSquare ${squares.join(" ")}` },
    BlackConsequentForcedSquare: { args: 1, Get: (squares) => `BlackConsequentForcedSquare ${squares.join(" ")}` },
    WhiteConsequentForcedSquare: { args: 1, Get: (squares) => `WhiteConsequentForcedSquare ${squares.join(" ")}` },
    ReflectiveKings: { args: 0, Get: () => `ReflectiveKings` },
    ChameleonChess: { args: 1, Get: (sequence) => `ChameleonChess ${sequence.join(" ")}` },
    FunctionaryChess: { args: 0, Get: () => `FunctionaryChess` },
    GlasgowChess: { args: 0, Get: () => `GlasgowChess` },
    AntiAndernachChess: { args: 0, Get: () => `AntiAndernachChess` },
    Isardam: { args: 2, Get: (typeB, rexInclusive) => `Isardam${typeB ? ` TypeB` : ""}${rexInclusive ? ` RexInclusive` : ""}` },
    ChecklessChess: { args: 0, Get: () => `ChecklessChess` },
    PromOnly: { args: 1, Get: (piecetypes) => `PromOnly ${piecetypes.join(" ")}` },
    ExclusiveChess: { args: 0, Get: () => `ExclusiveChess` },
    PhantomChess: { args: 0, Get: () => `PhantomChess` },
    WhiteTransmutedKing: { args: 0, Get: () => `WhiteTransmutedKing` },
    BlackTransmutedKing: { args: 0, Get: () => `BlackTransmutedKing` },
    WhiteReflectiveKing: { args: 0, Get: () => `WhiteReflectiveKing` },
    BlackReflectiveKing: { args: 0, Get: () => `BlackReflectiveKing` },
    AntiEinsteinChess: { args: 0, Get: () => `AntiEinsteinChess` },
    BlackRoyalSquare: { args: 0, Get: () => `BlackRoyalSquare` },
    WhiteRoyalSquare: { args: 0, Get: () => `WhiteRoyalSquare` },
    PlusChess: { args: 0, Get: () => `PlusChess` },
    BrunnerChess: { args: 0, Get: () => `BrunnerChess` },
    CentralChess: { args: 0, Get: () => `CentralChess` },
    ExtinctionChess: { args: 0, Get: () => `ExtinctionChess` },
    RepublicanChess: { args: 1, Get: (type = "Type2") => `RepublicanChess ${type}` },
    ActuatedRevolvingBoard: { args: 0, Get: () => `ActuatedRevolvingBoard` },
    MessignyChess: { args: 1, Get: (rexExclusive) => `MessignyChess${rexExclusive ? " RexExclusive" : ""}` },
    Woozles: { args: 1, Get: (rexExclusive) => `Woozles${rexExclusive ? " RexExclusive" : ""}` },
    BiWoozles: { args: 1, Get: (rexExclusive) => `BiWoozles${rexExclusive ? " RexExclusive" : ""}` },
    Heffalumps: { args: 1, Get: (rexExclusive) => `Heffalumps${rexExclusive ? " RexExclusive" : ""}` },
    BiHeffalumps: { args: 1, Get: (rexExclusive) => `BiHeffalumps${rexExclusive ? " RexExclusive" : ""}` },
    WhitePromSquares: { args: 1, Get: (squares) => `WhitePromSquares ${squares.join(" ")}` },
    BlackPromSquares: { args: 1, Get: (squares) => `BlackPromSquares ${squares.join(" ")}` },
    NoWhitePromotion: { args: 0, Get: () => `NoWhitePromotion` },
    NoBlackPromotion: { args: 0, Get: () => `NoBlackPromotion` },
    EiffelChess: { args: 0, Get: () => `EiffelChess` },
    ActuatedRevolvingCentre: { args: 0, Get: () => `ActuatedRevolvingCentre` },
    ShieldedKings: { args: 0, Get: () => `ShieldedKings` },
    NoWhiteCapture: { args: 0, Get: () => `NoWhiteCapture` },
    NoBlackCapture: { args: 0, Get: () => `NoBlackCapture` },
    AlphabeticChess: { args: 0, Get: () => `AlphabeticChess` },
    LineChameleonChess: { args: 0, Get: () => `LineChameleonChess` },
    AMU: { args: 0, Get: () => `AMU` },
    SingleBox: { args: 1, Get: (type = "Type2") => `SingleBox ${type}` },
    MAFF: { args: 0, Get: () => `MAFF` },
    OWU: { args: 0, Get: () => `OWU` },
    WhiteOscillatingKings: { args: 1, Get: (type) => `WhiteOscillatingKings ${type}`.trim() },
    BlackOscillatingKings: { args: 1, Get: (type) => `BlackOscillatingKings ${type}`.trim() },
    AntiKings: { args: 0, Get: () => `AntiKings` },
    WhiteSuperTransmutingKing: { args: 0, Get: () => `WhiteSuperTransmutingKing` },
    BlackSuperTransmutingKing: { args: 0, Get: () => `BlackSuperTransmutingKing` },
    UltraPatrol: { args: 0, Get: () => `UltraPatrol` },
    SwappingKings: { args: 0, Get: () => `SwappingKings` },
    RoyalDynasty: { args: 0, Get: () => `RoyalDynasty` },
    SAT: { args: 0, Get: () => `SAT` },
    StrictSAT: { args: 0, Get: () => `StrictSAT` },
    TakeMakeChess: { args: 0, Get: () => `Take&MakeChess` },
    MakeTakeChess: { args: 0, Get: () => `Make&TakeChess` },
    BlackSynchronMover: { args: 0, Get: () => `BlackSynchronMover` },
    WhiteSynchronMover: { args: 0, Get: () => `WhiteSynchronMover` },
    BlackAntiSynchronMover: { args: 0, Get: () => `BlackAntiSynchronMover` },
    WhiteAntiSynchronMover: { args: 0, Get: () => `WhiteAntiSynchronMover` },
    Masand: { args: 0, Get: () => `Masand` },
    MasandGeneralised: { args: 0, Get: () => `MasandGeneralised` },
    BGL: { args: 0, Get: () => `BGL` },
    AnnanChess: { args: 0, Get: () => `AnnanChess` },
    NannaChess: { args: 0, Get: () => `NannaChess` },
    NormalPawn: { args: 0, Get: () => `NormalPawn` },
    BlackChecks: { args: 0, Get: () => `BlackChecks` },
    GenevaChess: { args: 0, Get: () => `GenevaChess` },
    VaultingKings: { args: 2, Get: (pieceTypes, transmuting) => `VaultingKings ${pieceTypes === null || pieceTypes === void 0 ? void 0 : pieceTypes.join(" ")}${transmuting ? " Transmuting" : ""}`.trim() },
    WhiteVaultingKing: { args: 0, Get: () => `WhiteVaultingKing` },
    BlackVaultingKing: { args: 0, Get: () => `BlackVaultingKing` },
    ProteanChess: { args: 1, Get: (rexExclusive) => `ProteanChess${rexExclusive ? " RexExclusive" : ""}` },
    Lortap: { args: 0, Get: () => `Lortap` },
    Antikoeko: { args: 0, Get: () => `Antikoeko` },
    CastlingChess: { args: 0, Get: () => `CastlingChess` },
    ChameleonPursuit: { args: 0, Get: () => `ChameleonPursuit` },
    LosingChess: { args: 0, Get: () => `LosingChess` },
    GhostChess: { args: 0, Get: () => `GhostChess` },
    Football: { args: 0, Get: () => `Football` },
    WhiteAlphabeticChess: { args: 0, Get: () => `WhiteAlphabeticChess` },
    BlackAlphabeticChess: { args: 0, Get: () => `BlackAlphabeticChess` },
    KobulKings: { args: 0, Get: () => `KobulKings` },
    SuperGuards: { args: 0, Get: () => `SuperGuards` },
    Wormholes: { args: 0, Get: () => `Wormholes` },
    MarineChess: { args: 0, Get: () => `MarineChess` },
    UltramarineChess: { args: 0, Get: () => `UltramarineChess` },
    BackHome: { args: 0, Get: () => `BackHome` },
    FaceToFace: { args: 0, Get: () => `FaceToFace` },
    BackToBack: { args: 0, Get: () => `BackToBack` },
    CheekToCheek: { args: 0, Get: () => `CheekToCheek` },
    Disparate: { args: 0, Get: () => `Disparate` },
    SnekChess: { args: 0, Get: () => `SnekChess` },
    SnekCircleChess: { args: 0, Get: () => `SnekCircleChess` },
    ArgentinianChess: { args: 0, Get: () => `ArgentinianChess` },
    LostPieces: { args: 0, Get: () => `LostPieces` },
    PartialParalysis: { args: 0, Get: () => `PartialParalysis` },
    LeseMajeste: { args: 0, Get: () => `LeseMajeste` },
    Rokagogo: { args: 0, Get: () => `Rokagogo` },
    Breton: { args: 0, Get: () => `Breton` },
    PointReflection: { args: 0, Get: () => `PointReflection` },
    Bolero: { args: 0, Get: () => `Bolero` },
    BoleroInverse: { args: 0, Get: () => `BoleroInverse` },
    Influencer: { args: 0, Get: () => `Influencer` },
    ChameleonCirce: { args: 1, Get: (sequence) => `ChameleonCirce ${sequence.join(" ")}` },
};
exports.FairyAttributesDBNames = Object.keys(exports.FairyAttributesDB);
exports.CirceOptions = {
    RexInclusive: {
        description: "(default for AntiCirce and MarsCirce)",
        group: "Inclusion of the kings",
    },
    RexExclusive: {
        description: "(default otherwise)",
        group: "Inclusion of the kings",
    },
    LastMove: { description: "", group: "Relevant move/walk/side" },
    Clone: {
        description: "(also defines the walk of the reborn piece)",
        group: "Relevant move/walk/side",
    },
    Couscous: { description: "", group: "Relevant move/walk/side" },
    Mirror: {
        description: "(special meaning for Equipollents - see below)",
        group: "Relevant move/walk/side",
    },
    April: {
        description: "(followed by a list of piece walks)",
        group: "Restrition to piece walk",
    },
    Equipollents: {
        description: "",
        group: "Definition of the rebirth square(s)",
    },
    Parrain: {
        description: "(== Equipollents LastMove)",
        group: "Definition of the rebirth square(s)",
    },
    ContraParrain: {
        description: "(== Equipollents LastMove Mirror)",
        group: "Definition of the rebirth square(s)",
    },
    Rank: { description: "", group: "Definition of the rebirth square(s)" },
    File: { description: "", group: "Definition of the rebirth square(s)" },
    Symmetry: { description: "", group: "Definition of the rebirth square(s)" },
    Diagram: { description: "", group: "Definition of the rebirth square(s)" },
    PWC: { description: "", group: "Definition of the rebirth square(s)" },
    Antipodes: { description: "", group: "Definition of the rebirth square(s)" },
    Super: { description: "", group: "Definition of the rebirth square(s)" },
    "Take&Make": {
        description: "",
        group: "Definition of the rebirth square(s)",
    },
    Cage: { description: "", group: "Definition of the rebirth square(s)" },
    Diametral: { description: "", group: "Adaptation of the rebirth square" },
    VerticalMirror: {
        description: "",
        group: "Adaptation of the rebirth square",
    },
    Frischauf: { description: "", group: "Adaptation of the rebirth square" },
    "(Rank)": { description: "", group: "Adaptation of the rebirth square" },
    Chameleon: {
        description: "",
        group: "Adaptation of the reborn piece's walk",
    },
    Turncoat: { description: "", group: "Adaptation of the reborn piece's walk" },
    Einstein: { description: "", group: "Adaptation of the reborn piece's walk" },
    ReversalEinstein: {
        description: "",
        group: "Adaptation of the reborn piece's walk",
    },
    Relaxed: {
        description: "(default for Circe)",
        group: "Behaviour in case of occupied rebirth square",
    },
    Strict: {
        description: "(default otherwise)",
        group: "Behaviour in case of occupied rebirth square",
    },
    Assassin: {
        description: "",
        group: "Behaviour in case of occupied rebirth square",
    },
    Volcanic: {
        description: "",
        group: "Behaviour in case of occupied rebirth square",
    },
    Parachute: {
        description: "",
        group: "Behaviour in case of occupied rebirth square",
    },
    Calvet: { description: "(default)", group: "Self-block of the reborn piece" },
    Cheylan: { description: "", group: "Self-block of the reborn piece" },
};
/*

    The following "traditional" condition names can still be used;
  RexInclusive resp. RexExclusive can be added:

    traditional:		  Indication with option(s):

*/
exports.TraditionalConditions = {
    MirrorCirce: (rex) => `Circe Mirror`,
    PWC: (rex) => `Circe PWC`,
    CouscousCirce: (rex) => `Circe Couscous`,
    ChameleonCirce: (rex) => `Circe Chameleon`,
    EquipollentsCirce: (rex) => `Circe Equipollents`,
    FileCirce: (rex) => `Circe File`,
    DiagramCirce: (rex) => `Circe Diagram`,
    ParrainCirce: (rex) => `Circe LastMove Equipollents`,
    ContraParrain: (rex) => `Circe LastMove Equipollents Mirror`,
    SymmetryCirce: (rex) => `Circe Symmetry`,
    MirrorFileCirce: (rex) => `Circe File Mirror`,
    AntipodeanCirce: (rex) => `Circe Antipodes`,
    MirrorCirceClone: (rex) => `Circe Clone Mirror`,
    SuperCirce: (rex) => `Circe Super`,
    CirceClone: (rex) => `Circe Clone`,
    FrischaufCirce: (rex) => `Circe Frischauf`,
    DiametralCirce: (rex) => `Circe Diametral`,
    MirrorCouscousCirce: (rex) => `Circe Couscous Mirror`,
    CirceAssassin: (rex) => `Circe Assassin`,
    CirceTurncoats: (rex) => `Circe Turncoat`,
    CirceDoubleAgents: (rex) => `Circe Turncoat Mirror`,
    CageCirce: (rex) => `Circe Cage`,
    CirceTakeMake: (rex) => `Circe Take&Make`,
    VerticalMirrorCirce: (rex) => `Circe VerticalMirror`,
    AprilChess: (rex) => `Circe Super April`,
    MirrorAntiCirce: (rex) => `AntiCirce Mirror`,
    DiagramAntiCirce: (rex) => `AntiCirce Diagram`,
    FileAntiCirce: (rex) => `AntiCirce File`,
    SymmetryAntiCirce: (rex) => `AntiCirce Symmetry`,
    MirrorFileAnticirce: (rex) => `AntiCirce File Mirror`,
    AntipodeanAntiCirce: (rex) => `AntiCirce Antipodes`,
    EquipollentsAntiCirce: (rex) => `AntiCirce Equipollents`,
    AntiCloneCirce: (rex) => `AntiCirce Clone`,
    AntiSuperCirce: (rex) => `AntiCirce Super`,
    MarsMirrorCirce: (rex) => `MarsCirce Mirror`,
    AntiMarsMirrorCirce: (rex) => `AntiMarsCirce Mirror`,
    AntiMarsAntipodeanCirce: (rex) => `AntiMarsCirce Antipodes`,
    MirrorImmunChess: (rex) => `ImmunChess Mirror`,
    FileImmunChess: (rex) => `ImmunChess File`,
    DiagramImmunChess: (rex) => `ImmunChess Diagram`,
    MirrorFileImmunChess: (rex) => `ImmunChess File Mirror`,
    SymmetryImmunChess: (rex) => `ImmunChess Symmetry`,
    AntipodeanImmunChess: (rex) => `ImmunChess Antipodes`,
    EquipollentsImmunChess: (rex) => `ImmunChess Equipollents`,
};
function isTraditionalCondition(v) {
    return exports.TraditionalConditionsNames.indexOf(v) >= 0;
}
exports.isTraditionalCondition = isTraditionalCondition;
exports.TraditionalConditionsNames = Object.keys(exports.TraditionalConditions);
//# sourceMappingURL=fairesDB.js.map